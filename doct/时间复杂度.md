时间复杂度
=========

一. 时间复杂度定义
---------

- n -->表示数据规模
- O(f(n)) -->表示运行算法所需执行的指令数，与f(n)成正比。
- 学术界，严格定义，O(f(n))表示算法执行的上界（比如归并排序时间复杂度既可以是O(nlogn),也是O(n^2)）
- 业界，我们使用O表示算法执行的最低上界

eg: (a/b/c/d都是常数，影响不大)

算法名      | 所需指令数     
-------- | :-----------:  
二分查找法 O(logn) | a*logn 
寻找数组中最大/小值 O(n) | b*n
归并排序法 O(nlogn) | c*nlogn 
选择排序法 O(n^2) |d*n^2 

![算法常数比较 -w200](images/WeChat3e88a8060ec88868760a4597ba12c045.png "算法常数比较")

复杂度高的算法可能有执行数少的优势，数据规模较小时，这种算法是有意义的，比如排序算法数据规模较小时都可以转化为插入排序来优化（提升10%～15%）
这种优化属于细节优化，我们还是要追求时间复杂度低的算法

![算法复杂度函数 W 200](images/WeChatce179f240a80b86f5f67f2520805f7ad.png "算法复杂度函数")



二. 时间复杂度性质
--------

两段算法的算法时间复杂度的上界由量级较高的算法决定
**O(nlogn + n) = O(nlogn)**

当两段算法数据规模不同时，上界不一定由量级较高的算法决定
O(AlogA + B) 不一定= O(AlogA + B)
例如：邻接表进行遍历-->O(V + E)

>一道小题练练手～
>有一个字符串数组，将数组中的每一个字符串按照字符序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？
>  答：假设最长字符串长度为s；数组中有n个字符串；
>  对每个字符串排序：O(slogs)
>  将数组中的每个字符串按照字母序排序：O(n*slogs)
>  将整个字符串数组按照字典序排序：O(s*nlogn) *字符串排序比较次数为s*
>  所以： O(n*slogs) + O(s*nlogn) = O(n*slogs + s*nlogn)

