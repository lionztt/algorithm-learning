时间复杂度
=========

一. 时间复杂度定义
---------

- n -->表示数据规模
- O(f(n)) -->表示运行算法所需执行的指令数，与f(n)成正比。
- 学术界，严格定义，O(f(n))表示算法执行的上界（比如归并排序时间复杂度既可以是O(nlogn),也是O(n^2)）
- 业界，我们使用O表示算法执行的最低上界

eg: (a/b/c/d都是常数，影响不大)

算法名      | 所需指令数     
-------- | :-----------:  
二分查找法 O(logn) | a*logn 
寻找数组中最大/小值 O(n) | b*n
归并排序法 O(nlogn) | c*nlogn 
选择排序法 O(n^2) |d*n^2 

![算法常数比较 -w200](images/WeChat3e88a8060ec88868760a4597ba12c045.png "算法常数比较")

复杂度高的算法可能有执行数少的优势，数据规模较小时，这种算法是有意义的，  
比如排序算法数据规模较小时都可以转化为插入排序来优化（提升10%～15%）  
这种优化属于细节优化，我们还是要追求时间复杂度低的算法  

![算法复杂度函数 W 200](images/WeChatce179f240a80b86f5f67f2520805f7ad.png "算法复杂度函数")



二. 时间复杂度性质
--------

1.两段算法的算法时间复杂度的上界由量级较高的算法决定  
**O(nlogn + n) = O(nlogn)**  

当两段算法数据规模不同时，上界不一定由量级较高的算法决定  
**O(AlogA + B) 不一定= O(AlogA + B)**  
例如：邻接表进行遍历-->O(V + E)  

###### 一道小题练练手～  
> 有一个字符串数组，将数组中的每一个字符串按照字符序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？  
>&nbsp;&nbsp;&nbsp;&nbsp;答：假设最长字符串长度为s；数组中有n个字符串；  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个字符串排序：O(slogs)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将数组中的每个字符串按照字母序排序：O(n * slogs)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将整个字符串数组按照字典序排序：O(s * nlogn) *字符串排序比较次数为s*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以： O(n * slogs) + O(s * nlogn) = O(n * slogs + s * nlogn)  

2.算法复杂度在有些情况下是和用例情况相关的  

排序算法表格

算法名称 |最好时间分析|最差时间分析 |	平均时间复杂度 |	稳定度 |	空间复杂度
-------- | :-----------:  | :-----------:  | :-----------:  | :-----------:  | :-----------:  
冒泡排序| O(n)|	O(n^2) |	O(n^2) |	稳定 	|1
插入排序 | O(n)|O(n^2) |	O(n^2) |	稳定 |	1
选择排序 	|	O(n^2) |O(n^2) |	O(n^2)| 	不稳定 	|1
快速排序 |	O(n * log2n)|O(n^2) |	O(n * logn2)| 	不稳定| 	log2n~n
堆排序 |	O(n * log2n) |O(n * log2n) | O(n * log2n)| 	不稳定 |	1
希尔排序 | O(n) |O(n^2) |	O(n^1.3) (不确定) |	不稳定 	|1
归并排序|	O(n * log2n)|O(n * log2n) |	O(n *logn2)| 	稳定| 	n
基数排序|O(d(r+n))|O(d(r+n))|O(d(r+n))|稳定|rd+n

注：   
- r代表关键字基数，d代表长度，n代表关键字个数
- 还有一个桶排序

**我们最关心的还是平均情况**  


